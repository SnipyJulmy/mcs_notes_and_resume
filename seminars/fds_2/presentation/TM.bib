Automatically generated by Mendeley Desktop 1.19.3
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@inproceedings{Kossakowski2012,
abstract = {Developing rich web applications requires mastering different environments on the client and server sides. While there is considerable choice on the server-side, the client-side is tied to JavaScript, which poses substantial software engineering challenges, such as moving or sharing pieces of code between the environments. We embed JavaScript as a DSL in Scala, using Lightweight Modular Staging. DSL code can be compiled to JavaScript or executed as part of the server application. We use features of the host language to make client-side programming safer and more convenient. We use gradual typing to interface typed DSL programs with existing JavaScript APIs. We exploit a selective CPS transform already available in the host language to provide a compelling abstraction over asynchronous callback-driven programming in our DSL.},
author = {Kossakowski, Grzegorz and Amin, Nada and Rompf, Tiark and Odersky, Martin},
booktitle = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
doi = {10.1007/978-3-642-31057-7-19},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kossakowski et al. - 2012 - JavaScript as an embedded DSL.pdf:pdf},
isbn = {9783642310560},
issn = {03029743},
keywords = {DSL,JavaScript,Scala,programming languages},
pages = {409--434},
title = {{JavaScript as an embedded DSL}},
volume = {7313 LNCS},
year = {2012}
}
@techreport{Rossum:1995:PRM:869369,
address = {Amsterdam, The Netherlands, The Netherlands},
author = {Rossum, Guido},
publisher = {CWI (Centre for Mathematics and Computer Science)},
title = {{Python Reference Manual}},
year = {1995}
}
@book{Taylor:2009:SAF:1538494,
author = {Taylor, R N and Medvidovic, N and Dashofy, E M},
publisher = {Wiley Publishing},
title = {{Software Architecture: Foundations, Theory, and Practice}},
year = {2009}
}
@misc{filipkrikava2013,
author = {Krikava, Filip},
howpublished = {Presentation given to Rivier Scala / Clojure User Group},
title = {{Domain specific languages and Scala}},
year = {2013}
}
@article{Garreta2001,
author = {Garreta, Henri},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Garreta - 2001 - Techniques et outils pour la compilation.pdf:pdf},
pages = {1--67},
title = {{Techniques et outils pour la compilation}},
year = {2001}
}
@inproceedings{Rompf2010,
abstract = {Software engineering demands generality and abstraction, perfor- mance demands specialization and concretization. Generative pro- gramming can provide both, but developing high-quality program generators takes a large effort, even if a multi-stage programming language is used. We present lightweight modular staging, a library-based multi- stage programming approach that breaks with the tradition of syn- tactic quasi-quotation and instead uses only types to distinguish between binding times. Through extensive use of component tech- nology, lightweight modular staging makes an optimizing compiler framework available at the library level, allowing programmers to tightly integrate domain-specific abstractions and optimizations into the generation process. We argue that lightweight modular staging enables a form of language virtualization, i.e. allows to go from a pure-library em- bedded language to one that is practically equivalent to a stand- alone implementation with only modest effort.},
author = {Rompf, Tiark and Odersky, Martin},
booktitle = {Proceedings of the ninth international conference on Generative programming and component engineering - GPCE '10},
doi = {10.1145/1868294.1868314},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Rompf, Odersky - 2010 - Lightweight modular staging.pdf:pdf},
isbn = {9781450301541},
issn = {0001-0782},
pages = {127},
title = {{Lightweight modular staging}},
url = {http://portal.acm.org/citation.cfm?doid=1868294.1868314},
year = {2010}
}
@book{Toulson:2012:FEE:2385440,
address = {Newton, MA, USA},
author = {Toulson, Rob and Wilmshurst, Tim},
edition = {1st},
publisher = {Newnes},
title = {{Fast and Effective Embedded Systems Design: Applying the ARM Mbed}},
year = {2012}
}
@article{strembeckmarkzdunuwe2009,
abstract = {Building tailored software systems for a particular application domain is a complex task. For this reason, domain-specific languages (DSLs) receive a constantly growing attention in recent years. So far the main focus of DSL research is on case studies and experience reports for the development of individual DSLs, design approaches and implementation techniques for DSLs, and the integration of DSLs with other software development approaches on a technical level. In this paper, we identify and describe the different activities that we conduct when engineering a DSL, and describe how these activities can be combined in order to define a tailored DSL engineering process. Our research results are based on the experiences we gained from multiple different DSL development projects and prototyping experiments. Copyright {\textcopyright} 2009 John Wiley {\&} Sons, Ltd.},
address = {New York, NY, USA},
author = {Strembeck, Mark and Zdun, Uwe},
doi = {10.1002/spe.936},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Strembeck, Zdun - 2009 - An approach for the systematic development of domain-specific languages.pdf:pdf},
issn = {00380644},
journal = {Software - Practice and Experience},
keywords = {Applied software engineering,Domain-specific languages,Language engineering,Model-driven software development},
number = {15},
pages = {1253--1292},
publisher = {John Wiley $\backslash$$\backslash${\&} Sons, Inc.},
title = {{An approach for the systematic development of domain-specific languages}},
url = {http://dx.doi.org/10.1002/spe.v39:15},
volume = {39},
year = {2009}
}
@article{behnel2010cython,
author = {Behnel, S and Bradshaw, R and Citro, C and Dalcin, L and Seljebotn, D S and Smith, K},
doi = {10.1109/MCSE.2010.118},
issn = {1521-9615},
journal = {Computing in Science Engineering},
keywords = {Cython language;Fortran code;Python language exten},
number = {2},
pages = {31--39},
title = {{Cython: The Best of Both Worlds}},
volume = {13},
year = {2011}
}
@article{Gubbi20131645,
annote = {Including Special sections: Cyber-enabled Distributed Computing for Ubiquitous Cloud and Network Services ; Cloud Computing and Scientific Applications — Big Data, Scalable Analytics, and Beyond},
author = {Gubbi, Jayavardhana and Buyya, Rajkumar and Marusic, Slaven and Palaniswami, Marimuthu},
doi = {http://dx.doi.org/10.1016/j.future.2013.01.010},
issn = {0167-739X},
journal = {Future Generation Computer Systems},
keywords = {Cloud computing,Internet of Things,RFID,Smart environments,Ubiquitous sensing,Wireless sensor networks},
number = {7},
pages = {1645--1660},
title = {{Internet of Things (IoT): A vision, architectural elements, and future directions}},
url = {http://www.sciencedirect.com/science/article/pii/S0167739X13000241},
volume = {29},
year = {2013}
}
@article{Rompf2012,
abstract = {Scala-Virtualized extends the Scala language to better support hosting embedded DSLs. Scala is an expressive language that provides a flexible syntax, type-level computation using implicits, and other features that facilitate the development of embedded DSLs. However, many of these features work well only for shallow embeddings, i.e. DSLs which are implemented as plain libraries. Shallow embeddings automatically profit from features of the host language through linguistic reuse: any DSL expression is just as a regular Scala expression. But in many cases, directly executing DSL programs within the host language is not enough and deep embeddings are needed, which reify DSL programs into a data structure representation that can be analyzed, optimized, or further translated. For deep embeddings, linguistic reuse is no longer automatic.},
author = {Rompf, Tiark and Amin, Nada and Moors, Adriaan and Haller, Philipp and Odersky, Martin},
doi = {10.1007/s10990-013-9096-9},
issn = {1573-0557},
journal = {Higher-Order and Symbolic Computation},
number = {1},
pages = {165--207},
title = {{Scala-Virtualized: linguistic reuse for deep embeddings}},
url = {http://dx.doi.org/10.1007/s10990-013-9096-9},
volume = {25},
year = {2012}
}
@inproceedings{DBLP:conf/mipro/2015,
editor = {Biljanovic, Petar and Butkovic, Zeljko and Skala, Karolj and Mikac, Branko and Cicin-Sain, Marina and Sruk, Vlado and Ribaric, Slobodan and Gros, Stjepan and Vrdoljak, Boris and Mauher, Mladen and Sokolic, Andrej},
isbn = {978-9-5323-3082-3},
publisher = {IEEE},
title = {{38th International Convention on Information and Communication Technology, Electronics and Microelectronics, {\{}MIPRO{\}} 2015, Opatija, Croatia, May 25-29, 2015}},
url = {http://ieeexplore.ieee.org/xpl/mostRecentIssue.jsp?punumber=7153596},
year = {2015}
}
@article{Miotto2009,
abstract = {With the adoption of Domain Specific Languages (DSL), Model Driven Engineering (MDE) recognizes that ap- plication domains influence the way we specify and construct software systems. Notwithstanding their domain-specific nature, application systems often share common transversal concerns – for example, automotive, railway and aerospace domains alike require checking that critical temporal deadlines are met. It is not very wise therefore that every application domain should resolve transversal issues on its own: wherever possible instead, recourse should be made to the common body of knowledge that addresses the problem and solves it in a manner sanctioned by the scientific community. An effective MDE development environment should therefore subsume two distinct bodies of knowledge: the domain-specific one and its scientific complement.We are interested in devising a provably correct and affordable way to implement such an MDE environment. Two important questions however stand before us in that endeavor: 1. What language should we employ to enable the modeling of both bodies of knowledge: should we go for either UML profiles or metamodeling techniques? 2. What factors most impact the complexity and cost of proving model transformations correct? In this short paper we limit ourselves to elaborating on these problems, underpinning them with some background reasoning on their fundamental role to the very heart of MDE.},
author = {Miotto, Eric and Vardanega, Tullio},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Miotto, Vardanega - 2009 - On the integration of domain-specific and scientific bodies of knowledge in model driven engineering.pdf:pdf},
journal = {Procs. of STANDRTS},
keywords = {Domain Specific Language,Meta Object Facility,Platform Independent Model,Platform Specific Model,UML profile,Unified Modeling Language 2,applica- tion domain,composability,compositionality,correctness,language,metamodel,model,model-driven engineering,scientific body of knowledge,semantics,transformation},
title = {{On the integration of domain-specific and scientific bodies of knowledge in model driven engineering}},
url = {http://www.adams-project.org/standrts09/proceedings/miotto{\_}vardanega{\_}standrts09{\_}final.pdf},
year = {2009}
}
@article{Mosser2014,
abstract = {The Computer Science department of the University of Nice - Sophia Antipolis is offering a course dedicated to Model-Driven Engineering (MDE) in its graduate curriculum. This course exists since 2006, and was usually badly perceived by students, despite many reorganizations of both course contents and teaching methods. This paper is an experience report that describes the latest version of this course. It relies on a case study leveraging domain-specific languages and open-source microcontrollers to support the domain modeling of Internet of Things pieces of software. It exploits domain modeling as a pivot to illustrate MDE concepts (e.g., meta-modeling, model transformation), coupled to very practical labs where students experiment their models on real microcontrollers. This new version was well received by students.},
author = {Mosser, S{\'{e}}bastien and Collet, Philippe and Blay-Fornarino, Mireille},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Mosser, Collet, Blay-Fornarino - 2014 - Exploiting the Internet of Things to teach domain-specific languages and modeling the arduinoML.pdf:pdf},
issn = {16130073},
journal = {CEUR Workshop Proceedings},
pages = {45--54},
title = {{Exploiting the Internet of Things to teach domain-specific languages and modeling the arduinoML project}},
volume = {1346},
year = {2014}
}
@article{little_languages_little_maintenance,
abstract = {So-called little,ordomain-specific languages (DSLs), have the potential to make software maintenance simpler: domain-experts can directly use the DSL to make required routine modifications. On the negative side, however, more substantial changes may become more difficult: such changes may involve altering the domain-specific language. This will require compiler technology knowledge, which not every commercial enterprise has easily available. Based on experience taken from industrial practice, we discuss the role of DSLs in software maintenance, the dangers introduced by using them, and techniques for controlling the risks involved.},
address = {New York, NY, USA},
author = {Deursen, Arie Van and Klint, Paul and van Deursen, Arie and Klint, Paul},
doi = {10.1002/(SICI)1096-908X(199803/04)10:2<75::AID-SMR168>3.0.CO;2-5},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Deursen, Klint - 1998 - Little languages little maintenance.pdf:pdf},
issn = {1040-550X},
journal = {Journal of Software Maintenance},
keywords = {109-,97,a paper with the,acm sigplan workshop on,and phrases,and updated version of,component coordination,domain-specific language,domain-specific languages,dsl,ed,in s,interest rate products,kamin,language,note,pp,proceedings of the first,prototyping,same title which appeared,software generation,software maintenance,this is an extended},
number = {2},
pages = {75--92},
pmid = {23707069},
publisher = {John Wiley {\&} Sons, Inc.},
title = {{Little Languages: Little Maintenance}},
url = {http://dx.doi.org/10.1002/(SICI)1096-908X(199803/04)10:2{\%}3C75::AID-SMR168{\%}3E3.0.CO;2-5 http://doi.wiley.com/10.1002/{\%}28SICI{\%}291096-908X{\%}28199803/04{\%}2910{\%}3A2{\%}3C75{\%}3A{\%}3AAID-SMR168{\%}3E3.0.CO{\%}3B2-5},
volume = {10},
year = {1998}
}
@article{margusfreudenthal2010,
author = {Freudenthal, Margus},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Freudenthal - 2010 - Domain-Specific Languages in a Customs Information System.pdf:pdf},
journal = {IEEE Software},
number = {2},
pages = {65--71},
title = {{Domain-Specific Languages in a Customs Information System}},
volume = {27},
year = {2010}
}
@book{Waher:2015:LIT:2789499,
author = {Waher, Peter},
isbn = {1783553537, 9781783553532},
publisher = {Packt Publishing},
title = {{Learning Internet of Things}},
year = {2015}
}
@inproceedings{Hofer2008,
abstract = {The influential pure embedding methodology of embedding domain-specific languages (DSLs) as libraries into a general-purpose host language forces the DSL designer to commit to a single semantics. This precludes the subsequent addition of compilation, optimization or domain-specific analyses. We propose polymorphic embedding of DSLs, where many different interpretations of a DSL can be provided as reusable components, and show how polymorphic embedding can be realized in the programming language Scala. With polymorphic embedding, the static type-safety, modularity, composability and rapid prototyping of pure embedding are reconciled with the flexibility attainable by external toolchains.},
author = {Hofer, Christian and Ostermann, Klaus and Rendel, Tillmann and Moors, Adriaan},
booktitle = {Proceedings of the 7th international conference on Generative programming and component engineering - GPCE '08},
doi = {10.1145/1449913.1449935},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Hofer et al. - 2008 - Polymorphic embedding of dsls.pdf:pdf},
isbn = {9781605582672},
issn = {03029743},
pages = {137},
title = {{Polymorphic embedding of dsls}},
url = {http://portal.acm.org/citation.cfm?doid=1449913.1449935},
year = {2008}
}
@article{Sneps-Sneppe2016,
abstract = {This paper discusses the challenges of the Internet of Things programming. Sensing and data gathering from the various sources are often the key elements of applications for Smart Cities. So, the effective programming models for them are very important. In this article, we discuss system software models and solutions, rather than network related aspects. In our paper, we present the web-based domain-specific language for Internet of Things applications. Our goal is to present the modern models for data processing in Internet of Things and Smart Cities applications. In our view, the use of this kind of tools should seriously reduce the time to develop new applications. TS  - RIS},
author = {Sneps-Sneppe, Manfred and Namiot, Dmitry},
doi = {10.1109/ICUMT.2015.7382444},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Sneps-Sneppe, Namiot - 2016 - On web-based domain-specific language for Internet of Things.pdf:pdf},
isbn = {9781467392839},
issn = {2157023X},
journal = {International Congress on Ultra Modern Telecommunications and Control Systems and Workshops},
keywords = {actors,domain-specific languages,micro-service,middleware,software standards},
pages = {287--292},
title = {{On web-based domain-specific language for Internet of Things}},
volume = {2016-Janua},
year = {2016}
}
@article{Munoz2006,
author = {Munoz, J and Pelechano, Vicente and Cetina, Carlos},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Munoz, Pelechano, Cetina - 2006 - Implementing a pervasive meeting room A model driven approach.pdf:pdf},
isbn = {9728865511},
journal = {International Workshop on Ubiquitous Computing (IWUC 2006)},
pages = {13--20},
title = {{Implementing a pervasive meeting room: A model driven approach}},
url = {http://pdf.aminer.org/000/466/585/implementing{\_}a{\_}pervasive{\_}meeting{\_}room{\_}a{\_}model{\_}driven{\_}approach.pdf},
year = {2006}
}
@article{Kim2016,
abstract = {This paper proposes an abstract language for describing process-aware goals to be accomplished by collaborative smart-objects communities over the Internet of Things (IoT) platforms. The proposed abstract language is based upon the process-driven IoT-community computing model that is derived from a conceptual integration of the process-aware collaborations and the standardized IoT framework announced via the ITU-T SG132 Y.2060. We assume that a group of collaborative smart objects communities can be built-up statically, dynamically, or autonomously and their process-aware goals can be specified and achieved adaptively over an IoT-based community computing environment. We also strongly expect that the proposed abstract language will deliver us a meaningful means in specifying and achieving adaptive process-aware goals of the IoT-based communities formed in a ubiquitous computing society.},
author = {Kim, Meesun and Ahn, Hyun and Kim, Kwanghoon Pio},
doi = {10.1109/ICACT.2016.7423334},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kim, Ahn, Kim - 2016 - A process-aware goal description language for the Internet of Things community computing environments.pdf:pdf},
isbn = {9788996865063},
issn = {17389445},
journal = {International Conference on Advanced Communication Technology, ICACT},
keywords = {Web of Things,community computing model,process-aware goal description language,smart-objects collaboration,the Internet of Things,ubiquitous community computing architectures and s},
pages = {214--217},
title = {{A process-aware goal description language for the Internet of Things community computing environments}},
volume = {2016-March},
year = {2016}
}
@article{Rompf:2010:LMS:1942788.1868314,
address = {New York, NY, USA},
author = {Rompf, Tiark and Odersky, Martin},
doi = {10.1145/1942788.1868314},
issn = {0362-1340},
journal = {SIGPLAN Not.},
keywords = {code generation,domain-specific languages,language virtualization,multi-stage programming},
number = {2},
pages = {127--136},
publisher = {ACM},
title = {{Lightweight Modular Staging: A Pragmatic Approach to Runtime Code Generation and Compiled DSLs}},
url = {http://doi.acm.org/10.1145/1942788.1868314},
volume = {46},
year = {2010}
}
@misc{Arduino2017,
author = {Arduino},
booktitle = {online},
title = {{Arduino introduction}},
url = {https://www.arduino.cc/en/guide/introduction},
urldate = {2017-06-05},
year = {2017}
}
@misc{Miotto_onthe,
author = {Miotto, Eric and Vardanega, Tullio},
title = {{On the integration of domain-specific and scientific bodies of knowledge in Model Driven Engineering}},
year = {2010}
}
@misc{Benini2000,
abstract = {Dynamic power management (DPM) is a design methodology for dynamically reconfiguring systems to provide the requested services and performance levels with a minimum number of active components or a minimum load on such com- ponents. DPM encompasses a set of techniques that achieves energy-efficient computation by selectively turning off (or reducing the performance of) system components when they are idle (or partially unexploited). In this paper, we survey several approaches to system-level dynamic power management.We first describe how systems employ power-manageable components and how the use of dynamic re- configuration can impact the overall power consumption.We then analyze DPM implementation issues in electronic systems, and we survey recent initiatives in standardizing the hardware/software interface to enable software-controlled power management of hardware components.},
author = {Benini, Luca and Bogliolo, Alessandro and {De Micheli}, Giovanni},
booktitle = {IEEE Transactions on Very Large Scale Integration (VLSI) Systems},
doi = {10.1109/92.845896},
isbn = {1063-8210$\backslash$r1557-9999},
issn = {10638210},
keywords = {Energy conservation,Energy management,Optimization methods},
number = {3},
pages = {299--316},
title = {{A survey of design techniques for system-level dynamic power management}},
volume = {8},
year = {2000}
}
@article{midgar,
abstract = {Smart Objects and Internet of Things are two ideas that describe the future. The interconnection of objects can make them intelligent or expand their intelligence. This is achieved by a network that connects all the objects in the world. A network where most of the data traffic comes from objects instead of people. Cities, houses, cars or any other objects that come to life, respond, work and make their owner's life easier. This is part of that future. But first, there are many basic problems that must be solved. In this paper we propose solutions for many of these problems: the interconnection of ubiquitous, heterogeneous objects and the generation of applications allow inexperienced people to interconnect them. For that purpose, we present three possible solutions: a Domain Specific Language capable of abstracting the application generation problem; a graphic editor that simplifies the creation of that DSL; and an IoT platform (Midgar) able to interconnect different objects between them. Through Midgar, you can register objects and create interconnection between ubiquitous and heterogeneous objects through a graphic editor that generates a model defined by the DSL. From this model, Midgar generates the interconnection defined by the user with the graphical editor. ?? 2014 Elsevier B.V. All rights reserved.},
author = {{Gonzalez Garcia}, Cristian and {Pelayo G-Bustelo}, B. Cristina and {Pascual Espada}, Jordan and Cueva-Fernandez, Guillermo},
doi = {http://dx.doi.org/10.1016/j.comnet.2014.02.010},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Gonzalez Garcia et al. - 2014 - Midgar Generation of heterogeneous objects interconnecting applications. A Domain Specific Language prop.pdf:pdf},
isbn = {3498510339},
issn = {1389-1286},
journal = {Computer Networks},
keywords = {Domain Specific Language,Internet of Things,Model Driven Engineering,Sensor network,Smart Objects,Ubiquitous computing},
number = {May 2014},
pages = {143--158},
title = {{Midgar: Generation of heterogeneous objects interconnecting applications. A Domain Specific Language proposal for Internet of Things scenarios}},
url = {http://www.sciencedirect.com/science/article/pii/S1389128614000528},
volume = {64},
year = {2014}
}
@misc{Community2017,
author = {Community, Wikipedia},
booktitle = {online, accessed on 05.06.2017},
title = {{D-17B}},
url = {https://en.wikipedia.org/wiki/D-17B},
year = {2017}
}
@article{Hudak:1996:BDE:242224.242477,
address = {New York, NY, USA},
author = {Hudak, Paul},
doi = {10.1145/242224.242477},
issn = {0360-0300},
journal = {ACM Comput. Surv.},
number = {4es},
publisher = {ACM},
title = {{Building Domain-specific Embedded Languages}},
url = {http://doi.acm.org/10.1145/242224.242477},
volume = {28},
year = {1996}
}
@article{Tolvanen2010,
abstract = {Model integration is inescapable: any non-trivial system will be too large to fit sensibly in a single model. The model will have to be split, maybe into different aspects or languages, different modeler roles and tasks, different phases of the software development life cycle, etc. In Domain-Specific Modeling, the possibilities to integrate models are fundamentally better than with general-purpose languages as the company has full access to the language definitions. We describe and compare different ways to integrate DSM models, based on real world experience of what has been shown to work in practice on industrial scales. Copyright {\textcopyright} 2010 ACM.},
author = {Tolvanen, Juha-Pekka and Kelly, Steven},
doi = {10.1145/2060329.2060354},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Tolvanen, Kelly - 2010 - Integrating models with domain-specific modeling languages.pdf:pdf},
isbn = {9781450305495},
journal = {Proceedings of the 10th Workshop on Domain-Specific Modeling - DSM '10},
keywords = {domain-specific modeling,language integration,metamodel},
pages = {1},
title = {{Integrating models with domain-specific modeling languages}},
url = {http://dl.acm.org/citation.cfm?id=2060329.2060354},
year = {2010}
}
@article{VanDeursen2000,
abstract = {We survey the literature available on the topic of domain-specific languages as used for the construction and maintenance of software systems. We list a selection of 75 key publications in the area, and provide a summary for each of the papers. Moreover, we discuss terminology, risks and benefits, example domain-specific languages, design methodologies, and implementation techniques.},
author = {{Van Deursen}, A. and Klint, Paul and Visser, Joost},
doi = {10.1145/352029.352035},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Van Deursen, Klint, Visser - 2000 - Domain-specific languages an annotated bibliography.pdf:pdf},
issn = {03621340},
journal = {ACM Sigplan Notices},
number = {June},
pages = {26--36},
title = {{Domain-specific languages: an annotated bibliography}},
volume = {35},
year = {2000}
}
@misc{jakeedge2015,
author = {Edge, Jake},
title = {{Python without an operating system}},
url = {https://lwn.net/Articles/641244/},
year = {2015}
}
@misc{bendickson2016,
author = {Dickson, Ben},
title = {{4 Challenges to Consider Before Creating an IoT Device}},
url = {https://www.sitepoint.com/4-challenges-to-consider-before-creating-an-iot-device/},
year = {2016}
}
@article{Freudenthal2010,
author = {Freudenthal, Margus},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Freudenthal - 2010 - Domain-Specific Languages in a Customs Information System.pdf:pdf},
journal = {IEEE Software},
pages = {65--71},
title = {{Domain-Specific Languages in a Customs Information System}},
volume = {27},
year = {2010}
}
@article{Bertran2012,
abstract = {We present DiaSuite, a tool suite that uses a software design approach to drive the development process. DiaSuite focuses on a specific domain, namely Sense/Compute/Control (SCC) applications. It comprises a domain-specific design language, a compiler producing a Java programming framework, a 2D-renderer to simulate an application, and a deployment framework. We have validated our tool suite on a variety of concrete applications in areas including telecommunications, building automation, robotics and avionics. ?? 2011 Elsevier B.V. All rights reserved.},
author = {Bertran, Benjamin and Bruneau, Julien and Cassou, Damien and Loriant, Nicolas and Balland, Emilie and Consel, Charles},
doi = {10.1016/j.scico.2012.04.001},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Bertran et al. - 2014 - DiaSuite A tool suite to develop SenseComputeControl applications.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Domain-specific design language,Generative programming,Pervasive computing,Tool-based development methodology},
number = {4},
pages = {39--51},
title = {{DiaSuite: A tool suite to develop Sense/Compute/Control applications}},
url = {https://hal.inria.fr/hal-00702909},
volume = {79},
year = {2014}
}
@article{Hudak1996,
abstract = {I have believed for a very long time that abstraction is the most important factor in writing good software. As programming language researchers we design, and as software engineers we are trained to use, a variety of abstraction mechanisms: abstract data types, higher-order functions, monads, continuations, modules, classes, objects, etc. Particular languages support some of these mechanisms well, others not so well. An important point about these mechanisms is that they are fairly general|for example, most algorithmic strategies and computational structures can be implemented using either functional or object-oriented abstraction techniques. Although generality is good, we might ask what the $\backslash$ideal" abstraction for a particular application is. In my opinion, it is a programming language that is designed precisely for that application: one in which a person can quickly and eeectively develop a complete software system. It is not general at all; it should capture precisely the semantics of the application domain|no more and no less. In my opinion, a domain-speciic language is the $\backslash$ultimate abstraction." But we know all too well how diicult designing and implementing languages is, and we can be pretty sure that we won't get it right the rst time; it will evolve, and we will experience all of the diiculties associated with that evolution. So in fact the notion of a domain speciic language might not be very practical. Or is it? In this position paper I will outline several techniques that I believe can lead to the eeective use of this methodology. It begins with the assumption that we really don't want to build a programming language from scratch. Better, let's inherit the infrastructure of some other language|tailoring it in special ways to the domain of interest|thus yielding a domain-speciic embedded language (DSEL). Building on this base, we can then concentrate on semantical issues: viz. the interpreter of the language. Interestingly, we'll see that abstraction now kicks in at this leta-level: we can use abstraction techniques to build interpreters that are themselves easy to understand, highly modular, and straightforward to evolve. In the remainder of this paper I will describe the results of using the functional language Haskell to build DSELs. Haskell has several features that make it particularly suitable for this, but other languages could also be used. On the other hand, there are features that don't exist in any language (to my knowledge) that would make things even easier; there is much more work to be done. Domain Speciic Semantics It is surprisingly straightforward to design a DSEL for many speciic applications. We have done so already using Haskell in several domains: parser gen-eration, graphics, animation, simulation, music composition, and geometric region analysis, to 1 --Geometric regions are represented as functions: type Region = Point -{\textgreater} Bool --so to test a point's membership in a region, we do: inRegion :: Point -{\textgreater} Region -{\textgreater} Bool inRegio r = r p},
author = {Hudak, Paul and Haven, New},
doi = {10.1145/242224.242477},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Hudak, Haven - 1996 - Building Domain-Speci c Embedded Languages.pdf:pdf},
issn = {03600300},
journal = {ACM Computing Surveys},
number = {December},
pages = {1--7},
title = {{Building Domain-Speci c Embedded Languages}},
volume = {28},
year = {1996}
}
@misc{node-red,
author = {{IBM Emerging Technology Nick O'Leary}, Dave Conway-Jones},
title = {{Node-RED}},
url = {http://nodered.org/},
year = {2017}
}
@article{lang_comparison,
abstract = {The performance of different programming languages has previously been benchmarked using abstract mathematical algorithms, but not using standard bioinformatics algorithms. We compared the memory usage and speed of execution for three standard bioinformatics methods, implemented in programs using one of six different programming languages. Programs for the Sellers algorithm, the Neighbor-Joining tree construction algorithm and an algorithm for parsing BLAST file outputs were implemented in C, C++, C{\#}, Java, Perl and Python. Implementations in C and C++ were fastest and used the least memory. Programs in these languages generally contained more lines of code. Java and C{\#} appeared to be a compromise between the flexibility of Perl and Python and the fast performance of C and C++. The relative performance of the tested languages did not change from Windows to Linux and no clear evidence of a faster operating system was found. Source code and additional information are available from http://www.bioinformatics.org/benchmark/. This benchmark provides a comparison of six commonly used programming languages under two different operating systems. The overall comparison shows that a developer should choose an appropriate language carefully, taking into account the performance expected and the library availability for each language.},
author = {Fourment, Mathieu and Gillings, Michael R},
doi = {10.1186/1471-2105-9-82},
issn = {1471-2105},
journal = {BMC bioinformatics},
number = {1},
pages = {82+},
pmid = {18251993},
title = {{A comparison of common programming languages used in bioinformatics.}},
url = {http://dx.doi.org/10.1186/1471-2105-9-82},
volume = {9},
year = {2008}
}
@inproceedings{Ladd1994,
author = {Ladd, David A and Ramming, J Christopher},
booktitle = {Proceedings of the USENIX 1994 Very High Level Languages Symposium},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ladd, Ramming - 1994 - Two Application Languages in Software Production.pdf:pdf},
pages = {1--10},
title = {{Two Application Languages in Software Production}},
year = {1994}
}
@inproceedings{a.ladddavidrammingj.christopher1994,
address = {Santa Fe, New Mexico},
author = {{A. Ladd}, David and Ramming, J Christopher},
booktitle = {Proceedings of the USENIX 1994 Very High Level Languages},
month = {oct},
organization = {USENIX Association Berkeley},
pages = {Pages 10--10},
series = {VHLLS'94},
title = {{Two Application languages in software production}},
year = {1994}
}
@phdthesis{reneheinzl2007,
address = {Rosensteingasse 7-9/2 A-1160 Wien, {\"{O}}sterreich},
author = {Heinzl, Ren{\'{e}}},
school = {Technische universit{\"{a}}t Wien},
title = {{Concepts for Scientific Computing}},
type = {Dissertation},
year = {2007}
}
@article{Deursen1998,
abstract = {So-called little,ordomain-specific languages (DSLs), have the potential to make software maintenance simpler: domain-experts can directly use the DSL to make required routine modifications. On the negative side, however, more substantial changes may become more difficult: such changes may involve altering the domain-specific language. This will require compiler technology knowledge, which not every commercial enterprise has easily available. Based on experience taken from industrial practice, we discuss the role of DSLs in software maintenance, the dangers introduced by using them, and techniques for controlling the risks involved.},
author = {Deursen, Arie Van and Klint, Paul},
doi = {10.1002/(SICI)1096-908X(199803/04)10:2<75::AID-SMR168>3.0.CO;2-5},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Deursen, Klint - 1998 - Little languages little maintenance.pdf:pdf},
isbn = {1040-550X},
issn = {1040-550X},
journal = {Journal of Software Maintenance: Research and Practice},
keywords = {109-,97,a paper with the,acm sigplan workshop on,and phrases,and updated version of,component coordination,domain-specific language,domain-specific languages,dsl,ed,in s,interest rate products,kamin,language,note,pp,proceedings of the first,prototyping,same title which appeared,software generation,software maintenance,this is an extended},
number = {2},
pages = {75--92},
pmid = {23707069},
title = {{Little languages: little maintenance?}},
url = {http://doi.wiley.com/10.1002/{\%}28SICI{\%}291096-908X{\%}28199803/04{\%}2910{\%}3A2{\%}3C75{\%}3A{\%}3AAID-SMR168{\%}3E3.0.CO{\%}3B2-5},
volume = {10},
year = {1998}
}
@article{building_app_generator_cleaveland,
author = {Cleaveland, J Craig},
doi = {10.1109/52.17799},
issn = {0740-7459},
journal = {IEEE Software},
pages = {25--33},
publisher = {IEEE},
title = {{Building application generators}},
volume = {5},
year = {1988}
}
@article{Salihbegovic2015,
abstract = {With the goal of relieving the Internet of things (IoT)application designers of the complexities and heterogeneity of wireless sensory networks (WSNs), devices, communication media, protocols and operating systems, the development of higher level domain specific language has been undertaken. The result is DSL-4-IoT Editor-Designer, which is based on high level visual programming language, established on the class of visual domain specific modeling languages (VDSMLs). DSL-4-IoT is using formal presentations and abstract syntax in a metamodel. The visual front-end of the Editor has been developed in JavaScript language. The runtime execution of generated IoT application configuration files is done by the open source project “OpenHAB” runtime engine. In order to demonstrate the viability and usability of the developed DSL-4-IoT visual model based language, an experimental IoT testbed including 15 heterogeneous wireless sensory devices spanning two application domain (smart home and remote patient monitoring), has been designed and deployed.},
author = {Salihbegovic, A. and Eterovic, T. and Kaljic, E. and Ribic, S.},
doi = {10.1109/MIPRO.2015.7160420},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Salihbegovic et al. - 2015 - Design of a domain specific language and IDE for Internet of things applications.pdf:pdf},
isbn = {9789532330854},
journal = {2015 38th International Convention on Information and Communication Technology, Electronics and Microelectronics, MIPRO 2015 - Proceedings},
number = {May},
pages = {996--1001},
title = {{Design of a domain specific language and IDE for Internet of things applications}},
year = {2015}
}
@article{Mernik2005,
abstract = {Domain-specific languages (DSLs) are languages tailored to a specific application domain. They offer substantial gains in expressiveness and ease of use compared with general-purpose programming languages in their domain of application. DSL development is hard, requiring both domain knowledge and language development expertise. Few people have both. Not surprisingly, the decision to develop a DSL is often postponed indefinitely, if considered at all, and most DSLs never get beyond the application library stage.Although many articles have been written on the development of particular DSLs, there is very limited literature on DSL development methodologies and many questions remain regarding when and how to develop a DSL. To aid the DSL developer, we identify patterns in the decision, analysis, design, and implementation phases of DSL development. Our patterns improve and extend earlier work on DSL design patterns. We also discuss domain analysis tools and language development systems that may help to speed up DSL development. Finally, we present a number of open problems.},
address = {New York, NY, USA},
author = {Mernik, Marjan and Heering, Jan and Sloane, Anthony M.},
doi = {10.1145/1118890.1118892},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Mernik, Heering, Sloane - 2005 - When and how to develop domain-specific languages.pdf:pdf},
issn = {0360-0300},
journal = {ACM Computing Surveys},
keywords = {Domain-specific language,application language,domain analysis,language development system},
number = {4},
pages = {316--344},
pmid = {18335309},
publisher = {ACM},
title = {{When and How to Develop Domain-specific Languages}},
url = {http://doi.acm.org/10.1145/1118890.1118892 http://portal.acm.org/citation.cfm?doid=1118890.1118892},
volume = {37},
year = {2005}
}
@article{SanchezLopez:2012:ASI:2158828.2158837,
address = {London, UK, UK},
author = {{S{\'{a}}nchez L{\'{o}}pez}, Tom{\'{a}}s and Ranasinghe, Damith C and Harrison, Mark and Mcfarlane, Duncan},
doi = {10.1007/s00779-011-0399-8},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/S{\'{a}}nchez L{\'{o}}pez et al. - 2012 - Adding Sense to the Internet of Things.pdf:pdf},
issn = {1617-4909},
journal = {Personal Ubiquitous Comput.},
keywords = {Internet of things,RFID,Sensors,Smart Objects},
number = {3},
pages = {291--308},
publisher = {Springer-Verlag},
title = {{Adding Sense to the Internet of Things}},
url = {http://dx.doi.org/10.1007/s00779-011-0399-8},
volume = {16},
year = {2012}
}
@article{Moors2011,
abstract = {This paper describes Scala-Virtualized, which extends the Scala language and compiler with a small number of features that en-able combining the benefits of shallow and deep embeddings of DSLs. We demonstrate our approach by showing how to embed three different domain-specific languages in Scala. Moreover, we summarize how others have been using our extended compiler in their own research and teaching. Supporting artifacts of our tool in-clude web-based tutorials, nightly builds, and an Eclipse update site hosting an up-to-date version of the Scala IDE for Eclipse based on the Virtualized Scala compiler and standard library.},
author = {Moors, Adriaan and Rompf, Tiark and Haller, Philipp and Odersky, Martin},
file = {:home/snipy/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Moors et al. - 2011 - Tool Demo Scala-Virtualized.pdf:pdf},
journal = {Lampwww.Epfl.Ch},
keywords = {Language Constructs and Features},
pages = {1--10},
title = {{Tool Demo: Scala-Virtualized}},
url = {http://lampwww.epfl.ch/{~}phaller/doc/pepm2012.pdf},
year = {2011}
}
